[{"content":"서론 타일 기반 2D 게임을 만들던 중 한가지 고민에 빠졌다. 대부분의 엔티티가 사각형의 형태로 렌더링되는데, OpenGL의 VAO를 어떻게 설계해야 효율적일지 머릿속에서 정리가 쉽지않았다.\n이 글에서 내가 생각한 몇 가지 설계 전략과 그 장단점을 서술하고, 어떤 방식이 적합한지 비교분석 해보려고한다.\n렌더링 방식 먼저, 하나의 렌더링 엔티티는 하나의 텍스처를 사용한다. 텍스처는 아래 3가지 중 하나의 방식으로 렌더링된다.\nImage : 텍스처 전체를 렌더링한다. Sprite : NxM개의 그리드로 텍스처를 나누고, 그 중 하나를 렌더링한다. Atlas : NxM개의 그리드로 텍스처를 나누고, 이를 조합하여 하나의 큰 이미지를 렌더링한다. VAO는 정점의 위치정보와 텍스처좌표정보가 담긴 1개의 VBO와 정점 인덱스 정보가 담긴 EBO 1개로 이루어져있다. 최종적으로 glDrawElements()함수를 호출하여 하나의 quad를 렌더링한다.\n설계 전략 내가 고민해본 몇 가지 설계 전략을 소개한다.\n이미지마다 고유의 VAO를 갖는다. 이 방식은 Image, Sprite, Atalas의 인스턴스마다 하나의 고유한 VAO를 생성하는 방식이다. 문제점은 N개의 Image 인스턴스를 생성하면, 동일한 데이터를 갖는 VAO N개가 GPU 메모리에 할당된다. Image 뿐만아니라 NxM크기의 Sprite역시도 VAO의 정점위치정보가 중복되고, EBO 또한 중복될 가능성이 있다.\n그럼에도 불구하고 내가 이러한 방식을 떠올린 이유는 편리함이다. 코드 작성에있어서 이 방식은 데이터 중복이라는 점만 제외하면 따로 신경쓸 부분이 없다.\n텍스처 렌더링 방식마다 하나의 VAO를 공유한다. VAO를 텍스처 렌더링 방식에 따라 나눌 수 있다. Image는 4개의 정점으로 이루어진다. NxM Sprite는 (N + 1) * (M + 1)개의 정점으로 이루어진다. 이 방식은 이처럼 동일한 정점 정보를 갖는 VAO를 오직 1개만 만들어 공유함으로써 데이터 중복을 방지한다. 하지만 구현에 있어서 몇 가지 제약을 갖는다.\n먼저 NxM VAO를 생성 및 관리하는 클래스를 필요로한다. 이 클래스는 NxM VAO 인스턴스가 오직 하나만 유지되도록 관리한다. 나는 std::unordered_map에 각 인스턴스를 저장했다. 이 map의 key는 4바이트 정수타입으로 상위 2바이트는 열의 개수를, 하위 2바이트는 행의 개수를 나타낸다.\n이제 모든 NxM VAO는 오직 하나만 존재한다. 하지만 다음 문제는 이 VAO를 그릴때 발생한다. glDrawElements함수에 EBO 인덱스를 전달하여 텍스처의 일부만 그릴 수 있다. 이때 전달하는 인덱스에 따라 화면에 표시되는 위치가 달라진다. 예를들어 8개의 클립으로 이루어진 캐릭터 스프라이에서 마지막 클립이 그려지는 위치는 첫 번째 클립보다 클립 7개만큼 오른쪽일 것이다. 따라서 그릴 클립의 위치에따라 이를 보정해야한다. 나는 이 문제에 도착했을때 이를 해결하는 것이 배보다 배꼽이 더 커지는것이라 느꼈고, 다른 방법을 찾았다. 만약 이 문제를 해결하려면 필요한 보정값을 uniform형태로 셰이더에 전달하던 셰이더 내부에서 현재 정점의 텍스처 좌표로부터 보정값을 계산하던 정점의 위치를 보정해야한다.\n글을 작성하면서 떠오른 방법인데, VAO의 정점데이터를 구성할때 정점의 위치를 모두 동일한 Quad의 위치로 구성한다면 보정을 하지 않아도 동일한 위치에 Quad를 그릴 수 있을것이다.\n모든 이미지가 하나의 VAO를 공유한다. 나는 \u0026ldquo;렌더링에 사용되는 정점은 정사각형(Quad) 단 한개로 모두 동일하다\u0026quot;는 사실에서 아이디어를 얻었다. Quad를 이루는 정점의 위치는 신경쓸 필요없이 각 정점의 텍스처 좌표만 적절히 바꿔준다면 내가 원하는 렌더링 시스템을 구현할 수 있다는 것이다.\n이 방식은 Image가 VAO 한개를 정적 멤버로 갖고, 자신과 모든 하위클래스에서 이를 공유하여 사용함으로써 중복 데이터문제를 해결한다. 물론 구현하는데 몇 가지 제약이 따른다.\n먼저 VAO를 단순히 정적으로 생성할 수 없다. 나는 GLEW를 사용하는데, OpenGL API를 사용하기 전에 GLEW가 초기화 되어야한다. 따라서 VAO를 생성하는 시기를 그 이후로 미뤄야한다. 이 문제는 게으른 초기화(lazy initalization) 기법으로 해결했다.\n또 다른 문제는 텍스처의 다른 부분을 그리기 위해선 VAO의 정점 텍스처좌표를 수정해야 한다는 것이다. 버퍼데이터는 glBufferSubData()같은 함수를 통해 수정할 수 있다. 이 함수는 1. CPU와 GPU간의 데이터교환이 발생하고, 2. 상황에따라 버퍼의 데이터 수정은 비싼 연산이 될 수 있다 는 이유로 프로그램에 퍼포먼스 저하를 야기한다. 모든 이미지가 하나의 VAO를 공유하기 때문에 매 drawcall 마다(각 엔티티의 draw()함수를 호출 할 때 마다) 버퍼 데이터를 수정해야 할 것이다.\n어떤 방식을 사용해야할까? 이 글을 작성하는 시점을 기준으로 나는 \u0026ldquo;모든 이미지가 하나의 VAO를 공유한다\u0026rdquo; 방식으로 게임을 구현했다. 하지만 글을 작성할수록 이 방식보다는 \u0026ldquo;텍스처 렌더링 방식마다 하나의 VAO를 공유한다.\u0026rdquo; 방식이 더 효율적일 것 같다는 생각이 들었다. 두 번째 방식을 채택하지 않은 이유는 위에도 적었듯이 위치 보정에대한 추가과정이 필요했기 때문이었다. 하지만 글을 쓰면서 이를 해결할 수 있는 방법이 떠올랐고 이제 이 방식을 쓰지 않을 이유가 없다.\n이제 glBufferSubData()처럼 오버헤드가 큰 함수를 호출하지 않고, 추가적인 위치보정도 없이 glDrawElements()에 적절한 인덱스를 넘겨주는 것 만으로 원하는 결과를 얻을 수 있다.\n느낀점 사실 이미 렌더링 시스템은 이 글을 작성하기 전에 구현했다. 그럼에도 이 글을 작성한 이유는 그동안 고민했던 과정을 정리하고, 나중에 내가 비슷한 문제를 직면했을 때 찾아보기 위함이었다.\n하지만 글을 작성하면서 나는 더 좋은 방식을 떠올리게 되었다. 돌이켜보면 왜 저걸 당시에는 떠올리지 못했을까? 당연히 저렇게 하면 되는데 라는 생각이 들기도한다. 지금도 내가 떠올리지 못한, 어떻게보면 \u0026ldquo;당연한\u0026rdquo; 아이디어가 있을것이다. 만약 그렇다면 또 다른 글을 작성하면서 발견하지 않을까 생각한다.\n다시한번 글로 생각을 정리하는 과정이 얼마나 중요한지 깨닫게 되었다.\n","permalink":"https://zvcq.github.io/post/opengl/vao-design-strategies-for-tile-based-2d-games/","summary":"서론 타일 기반 2D 게임을 만들던 중 한가지 고민에 빠졌다. 대부분의 엔티티가 사각형의 형태로 렌더링되는데, OpenGL의 VAO를 어떻게 설계해야 효율적일지 머릿속에서 정리가 쉽지않았다.\n이 글에서 내가 생각한 몇 가지 설계 전략과 그 장단점을 서술하고, 어떤 방식이 적합한지 비교분석 해보려고한다.\n렌더링 방식 먼저, 하나의 렌더링 엔티티는 하나의 텍스처를 사용한다. 텍스처는 아래 3가지 중 하나의 방식으로 렌더링된다.\nImage : 텍스처 전체를 렌더링한다. Sprite : NxM개의 그리드로 텍스처를 나누고, 그 중 하나를 렌더링한다. Atlas : NxM개의 그리드로 텍스처를 나누고, 이를 조합하여 하나의 큰 이미지를 렌더링한다.","title":"타일 기반 2D 게임의 VAO 설계 전략"},{"content":"hello world sub1 sub-sub1 $$\\int_{a}^{b} x^2 dx$$\nsub-sub2 \\[\\int_a^b f(x)\\]\nsub2 sub3 ","permalink":"https://zvcq.github.io/post/test/","summary":"hello world sub1 sub-sub1 $$\\int_{a}^{b} x^2 dx$$\nsub-sub2 \\[\\int_a^b f(x)\\]\nsub2 sub3 ","title":"Test"},{"content":"","permalink":"https://zvcq.github.io/tags/","summary":"tags","title":"tags"}]